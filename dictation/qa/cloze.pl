#!/usr/bin/perl

# Last Edit: 2008 Jun 26, 05:55:29 PM

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;

my $man = 0;
my $help = 0;

GetOptions (
	'help|?' => \$help, man => \$man) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

use List::Util qw/shuffle/;
use IO::All;
use YAML qw/LoadFile DumpFile/;
use Text::Template;
use Parse::RecDescent;

my $textSource = io '/home/greg/li/students/j1.txt';
my @lines = $textSource->getlines;
my $lines = join '', @lines;
(my $cardIdentifier = $textSource ) =~ 
				s{.*/(\w+/(?:book|cloze)\d?)\.txt$}{$1: q\\&a};

my $blanksPerWord = 2;
my $blankedWordsPerLine = 3;
my $linesPerOuterSection = 3;

my $io = io 'cards.tmpl';
my $texString = "% This file, cards.tex was autogenerated on " . localtime() .  +"by cloze.pl\n";
$texString .= $io->all;

my @text;
our $lineN = 0;
our @qa;
# @{$qa[0]}{qw/from q r to/} = ('') x 4;
our $qaPair = -1;
our %speakers = ( A => 1, B => 1 );
our $previousSpeaker;
our $speaker = 'Nobody';
our $turn = 1;
our $problem;

our $RD_HINT=1;

my $qaGrammar = q[
	string: token(s) end | <error>
	token: header | footer | line(s)
	header: m/Conversation \d$/m {$::lineN++}
	footer: m/---/
		{
			if ( $::qa[$::qaPair] and not $::qa[$::qaPair]{r} )
			{
				push @{$::qa[$::qaPair]{r}}, 'The End.';
				$::qa[$::qaPair]{to} = $::lineN;
			}
			$::turn = 1;
			$::lineN++;
		}
	line: speaker statement
	speaker: m/^[^\n:]*(?=:)/m
	# speaker: m/^(Waitress|Customer)/
	{
		$::speakers{$item[1]} = 1;
		$::previousSpeaker = $::speaker;
		$::speaker = $item[1];
	}
	statement: greet | turn1 | turn2 | qwitha | problem | evalu
	greet:	<reject: do{$::turn > 1}>	m/^:	[^?\n]*
				(?:Hi\b|Good|morning|afternoon|Hello|Bye)
				[^?\n]*(\\.|!)$
				/mx
		{
			$::qaPair++;
			$::qa[$::qaPair]{from} = $::lineN;
			$::qa[$::qaPair]{q} = $::speaker . $item[2];
			$::lineN++;
			$::turn = 2;
		}
	turn1: <reject: $::turn == 2> m/^: [^\n]+(\\?| [^\n]+ [^\n]+)$/m
		{
			$::qaPair++;
			$::qa[$::qaPair]{from} = $::lineN;
			$::qa[$::qaPair]{q} = $::speaker . $item[2];
			$::lineN++;
			$::turn = 2;
		}
	qwitha: <reject: $::turn == 1> m/^: [^\n]*\\?[^\n]*$/m
		{
			push @{$::qa[$::qaPair]{r}}, $::speaker . $item[2];
			$::qa[$::qaPair]{to} = $::lineN;
			$::qaPair++;
			$::qa[$::qaPair]{from} = $::lineN;
			$::qa[$::qaPair]{q} = $::speaker . $item[2];
			$::lineN++;
			$::turn = 2;
		}
	problem: <reject: $::turn == 1 or $::problem> m/^: [^\n]*(?:Okay|problem)[^\n]*$/m
		{
			$::problem = 1;
			push @{$::qa[$::qaPair]{r}}, $::speaker . $item[2];
			$::qa[$::qaPair]{to} = $::lineN;
			$::qaPair++;
			$::qa[$::qaPair]{from} = $::lineN;
			$::qa[$::qaPair]{q} = $::speaker . $item[2];
			$::lineN++;
			$::turn = 2;
		}
	turn2: <reject: $::turn == 1> m/^: ((?<!one problem)[^?\n])*(\\.|!)$/m
		{
			push @{$::qa[$::qaPair]{r}}, $::speaker . $item[2];
			$::qa[$::qaPair]{to} = $::lineN;
			$::lineN++;
			$::turn = 1;
		}
	evalu: <reject: $::turn != 1> m/^: [^\n]*(?:too bad|Sounds good|Uh-huh|Thank|Sorry|Perfect|You're welcome)[^\n]{0,5}$/m
		{
			push @{$::qa[$::qaPair]{r}}, $::speaker . $item[2];
			$::qa[$::qaPair]{to} = $::lineN;
			$::lineN++;
			$::turn = 1;
		}
	#runon: <reject: $::previousSpeaker ne $::speaker> m/^:[^?\n]*(\\.|!)$/m
	#	{
	#		$::qaPair++;
	#		$::qa[$::qaPair]{from} = $::lineN;
	#		$::qa[$::qaPair]{q} = $::speaker . $item[2];
	#		$::lineN++;
	#		$::turn = 2;
	#	}
	end: m/^\Z/

]; 

my $qaParser = Parse::RecDescent->new($qaGrammar);
defined $qaParser->string($lines) or die "lineparse died: $?\n";

my $speakerString = "(" . (join ':|', keys %speakers) . ":)";
our $speakerTagRegex = qr/$speakerString/;

my %latex;
$latex{xy} = [ '0,0', '8,0', '0,4', '8,4', '0,8', '8,8', '0,12', '8,12'];
# $latex{xy} = [ '0,0', '8,0', '0,4', '8,4'];
$latex{label} = [1,2,3,4,5,6,7,8];
# $latex{label} = [1,2,3,4];
$latex{turn} = [1..2];
my $paperPosition = 0;
my $pageN = 1;

my $pairN = $qaPair;
$qaPair = 0;
	our $blankedText;

foreach my $pair ( @qa )
{

	our $wordN = 0;
			our $letter = qr/[A-Za-z0-9']/;
	# my $part1 = $pair->{q};
	# my $part2 = $pair->{r};
	$Parse::RecDescent::skip = '';
	my $letterGrammar = q[
	# @::blankedTurn1 = ();
	# @::blankedTurn2 = ();
		{
			my $punctuation = qr/[^A-Za-z0-9']+/;
			my $name = qr/[A-Z][A-Za-z0-9'-]*/; # qr/\u\w\w*\b/;
			my $word = qr/[A-Za-z0-9']+/;
			my $skip = '';
			my ($inWord, $arity) = (0) x 2;
			my $x = 0;
		}
		# line: tag longword(s) end | <error>
		tag: m/The End|$::speakerTagRegex/ { push @$::blankedText, $item[1]}
		# word: longword | punctuation
		# shortword: <reject: m/^$::letter{3,}/> password
		longword: 0of3word | 1of3word | 2of3word
		0of3word: <reject: $::wordN> letter(s)
						{ $::wordN = 1; }
		1of3word: <reject: not $::wordN==1> letter(s)
							{ $::wordN = 2; }
		2of3word: <reject: not $::wordN==2> letter(s)
							{ $::wordN = 0; }
		# punctuation: m/$punctuation/ { push @$::blankedText, $item[1] }
		password: m/^[A-Za-z0-9']*[^A-Za-z0-9']*/
		# password: m/^$::letter/
					{push @$::blankedText, $item[1]}
		line: tag letter(s) end | <error>
		# letter: passletter | startletter | 0of3letter | 1of3letter | 2of3letter
		letter: passletter | startletter | middleletter
			| lastletterplus # | punctuation
		passletter: <reject: $inWord or $arity> # m/\w{1}(?=$punctuation)/
					m/($::speakerRegex|\w)?$punctuation/
					# m/($::speakerRegex|\w)?[^A-Za-z0-9']/
			{ push @$::blankedText, $item[2]}
		startletter: <reject: $inWord> m/[A-Za-z0-9]/ #(?!$punctuation)/ 
			{
				$inWord=1;
				push @$::blankedText, $item[2];
			}
		middleletter: <reject: not $inWord>
						m/$::letter(?!$punctuation)/
			{
				push @$::blankedText, '\1';
				$inWord=1;
			}
		#0of3letter: <reject: not $inWord or $arity>
		#				m/$::letter(?!$punctuation)/
		#	{
		#		push @$::blankedText, '\1';
		#		$arity++;
		#	}
		#1of3letter: <reject: not $inWord or not ($arity == 1)>
		#				m/$::letter(?!$punctuation)/
		#	{
		#		push @$::blankedText, $item[2];
		#		$arity++;
		#	}
		#2of3letter: <reject: not $inWord or not ($arity == 2)>
		#				m/$::letter(?!$punctuation)/
		#	{
		#		push @$::blankedText, $item[2];
		#		$arity = 0;
		#	}
		lastletterplus: <reject: not $word> m/[A-Za-z0-9'][^A-Za-z0-9']+/
		# lastletter: m/$::letter(?=$punctuation)/
			{
				#my $puncString = substr($item[2],1);
				#push @$::blankedText, '\1'. $puncString if
				#				$arity == 1;
				#push @$::blankedText, $item[2] if ($arity == 0)
				#			or ($arity == 2);
				push @$::blankedText, $item[2];
				$inWord = 0;
				# $arity = 0;
			}
		end: m/^\Z/
		{
			push @$::blankedText, '\\\\\\\\';
		}
		]; 

	my $preSection = '\normalsize '
	. (join '\\\\', @lines[$pair->{from}-2..$pair->{from}-1])
			. '\\\\';
	my $postSection = '\normalsize '
		. (join '\\\\', @lines[$pair->{to}+1..$pair->{to}+2])
			. '\\\\';
	my @threeWords = qw/ 0of3word 1of3word 2of3word /;
		my @index = (0 .. 2);
	sub cycle
	{
		my @index = @_;
		return map { $_%3 } ( map { $_+1 } @index );
	}
		my $turn1Parser = 
			Parse::RecDescent->new($letterGrammar);
		my $turn2Parser = 
			Parse::RecDescent->new($letterGrammar);
	# foreach ( 0..2 )
	# {
		@index = map { $_%3 } ( map { $_+1 } @index );
		my $nextword =
"$threeWords[$index[0]]: <reject: m/^[\\w']{1,2}/ and \$::wordN> letter(s) {\$::wordN=1;}
$threeWords[$index[1]]: <reject: m/^[\\w']{1,2}/ and not \$::wordN==1> password{\$::wordN=2}
$threeWords[$index[2]]: <reject: m/^[\\w']{1,2}/ and not \$::wordN==2> password {\$::wordN=0}";

		# $turn1Parser->Replace($nextword);
		undef $::blankedText;
		defined $turn1Parser->line($pair->{q}) or
					die "letterparse died: $?\n";
		my @blankedTurn1 = @$::blankedText;
		# $turn2Parser->Replace($nextword);
		undef $::blankedText;
		(defined $turn2Parser->line($_) or
		die "letterparse died: $?\n") foreach @{ $pair->{r} };
		my @blankedTurn2 = @$::blankedText if $::blankedText;

		#my $adjacencyPair = '\Large ' . (join '', @blankedTurn1, 
		#				(join '\\\\', @$part2), '\\\\');
		my $adjacencyPair = '\Large '.
					(join '', @blankedTurn1, @blankedTurn2);

		$paperPosition = $paperPosition % 8;
		# $paperPosition = $paperPosition % 4;
		$texString .= 
"\\begin{textblock}{8}($latex{xy}[$paperPosition])
\\textblocklabel{picture$latex{label}[$paperPosition]}
\\mycard{\\small $cardIdentifier}{$preSection}{$adjacencyPair}{$postSection}
\\end{textblock}
";
			$paperPosition++;
		# if ($paperPosition == 4)
		if ($paperPosition == 8)
		{
			$texString .= "\\begin{tiny}$pageN\\end{tiny}\\newpage\n\n";
			$pageN++;
			
		}
	# }
}

$texString .= '
\end{document}
';

open TEX, ">cards.tex";
print TEX $texString;

__END__

=head1 NAME

Question-answer adjacency pairs

=head1 SYNOPSIS

./cloze.pl

=head1 DESCRIPTION

B<cloze.pl> selects question-answer adjacency pairs from a longer dialog, totally blanks both question and answer turns and creates A7 cards with the blanked pair and the pre/post context.

This makes it suitable for students doing dictation of, or repeating, small parts of the dialog.

=cut
